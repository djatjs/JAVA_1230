<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
        배열 선언 방법
        var 배열명 = [];
        var 배열명 = [값1, 값2, 값3, ...];
        var 배열명 = new Array(크기);
        var 배열명 = new Array(값1, 값2, 값3, ...);
        var 배열명 = Array(값1, 값2, 값3, ...);

        js 배열에서는 값들이 다른 자료형이어도 하나의 배열에 넣을 수 있음
        */
        let arr = [1,'1',true,'1', {
            name : '홍길동',
            age : 21
        }];
        document.write(`배열 : ${arr}, <hr>`);

        /*
        요소 추가 및 삭제
        push() : 값을 배열 끝에 추가
        unshift() : 값을 배열 처음에 추가
        pop() : 배열의 끝에 있는 값 제거하고 리턴
        shift() : 배열의 처음에 있는 값 제거하고 리턴
        */
        let obj = arr.pop();
        document.write('<h3>pop을 이용하여 제거</h3>');
        document.write(`제거한 값 : ${obj}<br>`);
        document.write(`배열 : ${arr}<br>`);

        document.write('<h3>push을 이용하여 추가</h3>');
        arr.push("안녕하세여");
        document.write(`배열 : ${arr}<br>`);

        let val = arr.shift();
        document.write('<h3>shift을 이용하여 제거</h3>');
        document.write(`제거한 값 : ${val}<br>`);
        document.write(`배열 : ${arr}<br>`);

        document.write('<h3>unshift를 이용하여 추가</h3>');
        arr.unshift("ㅋ");
        document.write(`배열 : ${arr}<hr>`);

        /*
        요소 탐색
        1. indexOf(값) : 값이 배열에 앞에서부터 몇번지에 있는지 반환
            - 없으면 -1 반환
            - 값과 타입이 같아야 함
        2. lastIndexOf(값) : 값이 배열에 뒤에서부터 몇번지에 있는지 반환
            - 없으면 -1 반환
            - 값과 타입이 같아야 함
        3. includes(값) : 값이 배열에 있는지 여부를 반환
            - 있으면 true, 없으면 false
        */
        document.write('<h3>탐색</h3>');
        var search ='1';
        document.write(`배열에 ${search}가 앞에서 몇번지에 있나요? : ${arr.indexOf(search)} <br>`);
        document.write(`배열에 ${search}가 뒤에서 몇번지에 있나요? : ${arr.lastIndexOf(search)} <br>`);
        document.write(`배열에 ${search}가 있나요? : ${arr.includes(search)} <hr>`);

        /*
        join() : 배열 값들 사이에 구분자를 추가하여 하나의 문자열로 반환
        */
        document.write('<h3>join</h3>');
        document.write(arr.join(","), '<br>');
        document.write(arr.join(", "), '<br>');
        document.write(arr.join("/"), '<hr>');

        /*
        잘라내기
        slice(start?, end?) : 배열을 잘라내서 부분 배열을 생성해서 반환
            - 원본은 안 바뀜
            - start번지에서 end-1번지까지 부분 배열을 반환
            - start와 end는 생략 가능 -> 전체 배열을 반환
        
        splice(start, count?)
            - 배열에서 start번지부터 count개만큼 삭제해서 삭제된 값을 반환
            - 원본 배열은 바뀜
        
        splice(start, count?, 추가값1, 추가값2, ...)
            - start번지부터 count개만큼 삭제하고 추가값을 추가
            - 삭제된 값을 반환
        */
        document.write('<h3>잘라내기</h3>');
        document.write('<h4>slice</h4>');
        var arr2 = arr.slice();
        var arr3 = arr.slice(2,4);
        document.write(`원본 : ${arr}<br>`);
        document.write(`splice() : ${arr2}<br>`);
        document.write(`splice(2,4) : ${arr3}<br>`);

        document.write('<h4>splice</h4>');
        document.write(`원본 : ${arr}<br>`);
        var arr4 = arr.splice(0,1);
        document.write(`splice(0,1) : ${arr4}<br>`);
        document.write(`작업 후 원본 : ${arr}<br>`);
        var arr5 = arr.splice(0,2, 3,4,5,6,7,8);
        document.write(`splice(0,2, 3,4,5,6,7,8) : ${arr5}<br>`);
        document.write(`작업 후 원본 : ${arr}<hr>`);

        /*
        map(콜백함수) : 각 요소에 콜백함수를 호출해서 만들어진 새로운 배열을 반환
            - 원본은 바뀌지 않음
        
        filter(콜백함수) : 콜백함수 결과가 true인 요소들만 필터링

        find(콜백함수) : 콜백함수가 처음으로 true가 되는 요소를 반환

        forEach(콜백함수) : 각 요소에 콜백함수를 실행

        reduce(콜백함수, 초기값) : 콜백함수를 이용하여 하나의 값을 도출

        map, filter, find, forEach의 콜백함수 형태
        (value, index, array) => {
            실행문;
        }
        - value : 배열에서 꺼낸 값
        - index : 배열에서의 위치(번지)
        - array : 배열 전체
        */
        document.write('<h3>map</h3>');
        arr=[1,2,3,4,5,6,7,8];
        let arr6 = arr.map(v=>v*2);
        document.write(`원본 : ${arr}<br>`);
        document.write(`원본*2 : ${arr6}<br>`);
        let arr7 = arr.map(v=>{
            return {
                age : v
            }
        });
        
        document.write(`원본 : ${arr}<br>`);
        document.write(`원본=>객체 배열 : ${arr7}<br>`);
        document.write('<hr>');

        document.write('<h3>filter</h3>');
        let arr8 = arr.filter(v=>v%2==0);
        document.write(`원본 : ${arr}<br>`);
        document.write(`짝수만 : ${arr8}<br>`);
        document.write('<hr>');

        document.write('<h3>find</h3>');
        let arr9 = arr.find(v=>v%2==0);
        document.write(`원본 : ${arr}<br>`);
        document.write(`첫번째 짝수 : ${arr9}<br>`);
        document.write('<hr>');
        
        document.write('<h3>forEach</h3>');
        arr.forEach((v,i)=>{
            document.write(`${i}번지 : ${v}<br>`);
        });
        document.write('<hr>');

        document.write('<h3>reduce</h3>'); //누적을 해가는 작업을 할 때 사용하나봄
        arr.push('abc');
        arr.push(NaN);
        arr.push(Infinity);
        //숫자 원소들만 합해서 더해보기
        var sum = arr.reduce((acc, v)=>{
            if(typeof v != 'number'||isNaN(v)||!isFinite(v)){
                return acc;
            }
            return acc+v;
        },0); //0이 acc의 초기값
        document.write(`배열의 합 : ${sum}<hr>`);
    </script>
</head>
<body>
    
</body>
</html>